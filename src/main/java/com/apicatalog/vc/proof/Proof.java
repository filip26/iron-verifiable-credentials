package com.apicatalog.vc.proof;

import java.net.URI;
import java.util.Collection;
import java.util.Map;

import com.apicatalog.controller.key.VerificationKey;
import com.apicatalog.controller.method.VerificationMethod;
import com.apicatalog.cryptosuite.CryptoSuite;
import com.apicatalog.cryptosuite.CryptoSuiteError;
import com.apicatalog.cryptosuite.VerificationError;
import com.apicatalog.ld.DocumentError;
import com.apicatalog.ld.DocumentError.ErrorType;
import com.apicatalog.linkedtree.orm.Fragment;
import com.apicatalog.linkedtree.orm.Id;
import com.apicatalog.linkedtree.orm.Provided;
import com.apicatalog.linkedtree.orm.Term;
import com.apicatalog.linkedtree.orm.Type;
import com.apicatalog.linkedtree.orm.Vocab;

/**
 * Represents generic VC/VP proof.
 */
@Fragment(generic = true)
@Vocab("https://w3id.org/security#")
public interface Proof {

    /**
     * The proof unique identifier. Optional.
     * 
     * @return {@link URI} representing the proof id
     */
    @Id
    URI id();

    @Type
    Collection<String> type();

    /**
     * A set of parameters required to independently verify the proof, such as an
     * identifier for a public/private key pair that would be used in the proof.
     * Mandatory
     *
     * @return {@link VerificationMethod} to verify the proof signature
     */
    @Term("verificationMethod")
    VerificationMethod method();

    /**
     * One of any number of valid representations of proof value generated by the
     * Proof Algorithm.
     *
     * @return the proof value
     */
    @Term("proofValue")
    @Provided
    ProofValue signature();

    /**
     * Must be processed after the previous proof. Allow to create a chain of
     * proofs. Optional.
     * 
     * @return {@link URI} uniquely identifying the previous proof
     */
    @Term
    Collection<URI> previousProof();

    /**
     * Returns a {@link CryptoSuite} used to create and to verify the proof value.
     * 
     * @return {@link CryptoSuite} attached to the proof.
     */
    @Provided
    CryptoSuite cryptosuite();

    /**
     * The intent for the proof, the reason why an entity created it. e.g. an
     * assertion, authentication.
     *
     * @return {@link URI} identifying the purpose
     */
    @Term("proofPurpose")
    URI purpose();

    /**
     * Validate the proof data. e.g required properties, values range, a match with
     * parameters, etc.
     * 
     * @param params custom, suite specific parameters to validate against
     * 
     * @throws DocumentError if the proof is not valid, e.g. is created in the
     *                       future
     */
    default void validate(Map<String, Object> params) throws DocumentError {
        throw new DocumentError(ErrorType.Unknown, "Proof");
    }

    /**
     * Verify the proof integrity and a signature genuity.
     * 
     * @param method
     * @throws VerificationError
     * @throws DocumentError
     */
    default void verify(VerificationKey method) throws VerificationError, DocumentError {
        throw new DocumentError(ErrorType.Unknown, "Proof");
    }

    /**
     * Derive a new selective disclosure document. Supported by selective disclosure
     * proofs only. {@link UnsupportedOperationException} is thrown otherwise.
     * 
     * @param selectors
     * 
     * @return an origin document with a new derived proof attached
     * 
     * @throws CryptoSuiteError
     * @throws DocumentError
     * @throws UnsupportedOperationException
     */

    default Proof derive(Collection<String> selectors) throws CryptoSuiteError, DocumentError {
        throw new UnsupportedOperationException("The proof does not support a selective disclosure.");
    }
}
